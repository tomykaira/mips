1. 初めに
暫定ですが、新コンテスト用のプログラムのFractal flameです。
Fractal flameは、基本的には3次元→3次元(2次元のx,y座標と色のインデックス値)の関数群で構成されています。
最初に種としてランダムな点を与えた後は、ランダムで関数群の中から一つを選んで現在の点に適用する、という動作を繰り返します。
そうすると、関数の選択確率や関数それぞれの挙動に応じて、2次元の画像の上に点の軌跡の濃淡が現れます。

基本的にはこの論文を参考にしています。わからないときはこの論文を読むと良いでしょう。
→http://flam3.com/flame.pdf

配布した入力ファイルはテスト済みですが、もしかしたらバグがあるかもしれないです。
何か不具合などありましたら、報告をよろしくお願いします。


2. 特徴（以前の課題であるRayTraceと比べて）：
 a.コンパイラ方面
    ・簡単なパターンマッチを使う（Indirect Branchが現れる）
    ・タプルを戻り値として用いる
      -> mincamlでは、タプルを戻り値として使うとヒープ領域が消費されます
      -> GCか、戻り値のタプルをスタック上に配置できる改良が必要となります

 b.コア方面
    ・メモリを大量に消費する
      -> raytraceでは2MB-4MB程度で計算が可能でしたが、Fractal Flameでは数百MB使います。そのため、DRAMを使った計算が必須となります
    ・キャッシュが重要になる
      -> DRAMは遅いので、SRAMをキャッシュとして適当に使うことが実行時間に大きく聞いてくると思います。その際、アドレスマッピングやキャッシュの置換アルゴリズム、キャッシュブロックサイズ、Way数といった要素が性能に大きな影響を及ぼすため、シミュレータで評価を行いつつ実装方式を検討すると良いでしょう

 c.ライブラリ方面
    ・複雑な関数が多用される
      -> atan,sin,cos,exp,log,sqrt,sinh,cosh,floor
    ・乱数を使う


3. コードの変更について
RayTraceプログラムを参考にすると、変更が必要となる関数は以下のものになると思われます。
Array.make
Array.init
read_float
read_int

また、乱数生成関数（random_int, random_float）は現在はxorshiftを使っていますが、ここはハードウェア実装を用いたり、異なるソフトウェア実装を使ったりしても構いません。
出力フォーマットは今は.ppmのP3になっていますが、これはP6に変えても構いません。
その他atan,sin,cos,exp,log,sqrt,sinh,cosh,floorといった算術演算は、ソフトウェア実装でもハードウェア実装でも良いということにします。ただし、「最終的な出力結果の見た目が配布プログラムと変わらないこと」を条件とします。この条件をクリアしているかどうかはTAが判断します。

基本的に、変更しても良い部分は以下の様にコメントが書いてあるので読んでみてください。
(**************** ここから、関数の定義の変更ok *******************)
(**************** ここまで、関数の定義の変更ok *******************)


4. 本番用データについて
今のところ、contest/以下のファイルを本番用として使おうと考えています。
greenS(M,L).lorは、画像のサイズの小さい順にS<M<Lとなっています。本番ではMかLが動けば良いなぁと思います。


5. 使い方
実行したい場合は、展開したフォルダでmakeを実行してください。コンパイルにはocamloptを使います。
Simple以下に入っているファイルは、構成が非常に単純なデータになっています。
サンプルの入力画像はおいおい追加します。

make
./loreley < Simple/simple11.lor > out.ppm
./loreley < Contest/greenS.lor > greenS.ppm


6. 履歴
2012/11/01: ver 0.1
  とりあえず公開
